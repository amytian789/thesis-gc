stop("The number of sheets must be even. For any graph pair,
each graph's sheet must be next to the other's.")
}
data <- vector("list",length(g))
for (i in 1:g) {
# First number = number of nodes in graph
data[[i]] <- as.vector(t( xlsx::read.xlsx("data.xlsx", sheetIndex = i, header = FALSE) ))[-1]
}
################################## Compute differences for all given graph pairs
# Setting parameters
gSumm <- c("cen_deg","cen_clo","cen_bet","ast",
"com_rw","com_im","com_bet","dis","eco","edh")
distf <- "l2"
gc <- vector("list",length(g/2))
for (i in seq(1,g,2)) {
# g1 and g2 must have the same number of nodes!
if (data[[i]][1] != data[[i+1]][1]) {
stop(paste("g1 and g2 must have the same # of nodes.
Error in sheets",i,"and",i+1))
}
# Create g1 and g2 as igraphs
g1 <- igraph::make_empty_graph(n = data[[i]][1], directed = FALSE)
g1 <- igraph::add_edges(g1, data[[i]][-1])
g2 <- igraph::make_empty_graph(n = data[[i+1]][1], directed = FALSE)
g2 <- igraph::add_edges(g2, data[[i+1]][-1])
# Call the engine to compute difference between g1 and g2
gc[[(i+1)/2]] <- GC_engine(g1=g1,g2=g2,gSumm=gSumm,distf=distf)
}
help(stopifnot)
setwd("C:/Users/amyti/Documents/Amy - COLLEGE/THESIS/thesis-gc/")
source("GC_engine.R")
source("dist_engine.R")
library(xlsx)
library(igraph)
library(clusteval)
################################## Read in data.
g <- length(xlsx::getSheets(loadWorkbook("data.xlsx")))
if (g %% 2 != 0) {
stop("The number of sheets must be even. For any graph pair,
each graph's sheet must be next to the other's.")
}
data <- vector("list",length(g))
for (i in 1:g) {
# First number = number of nodes in graph
data[[i]] <- as.vector(t( xlsx::read.xlsx("data.xlsx", sheetIndex = i, header = FALSE) ))[-1]
}
################################## Compute differences for all given graph pairs
# Setting parameters
gSumm <- c("cen_deg","cen_clo","cen_bet","ast",
"com_rw","com_im","com_bet","dis","eco","edh")
distf <- "l2"
gc <- vector("list",length(g/2))
for (i in seq(1,g,2)) {
# g1 and g2 must have the same number of nodes!
if (data[[i]][1] != data[[i+1]][1]) {
stop(paste("g1 and g2 must have the same # of nodes.
Error in sheets",i,"and",i+1))
}
# Create g1 and g2 as igraphs
g1 <- igraph::make_empty_graph(n = data[[i]][1], directed = FALSE)
g1 <- igraph::add_edges(g1, data[[i]][-1])
g2 <- igraph::make_empty_graph(n = data[[i+1]][1], directed = FALSE)
g2 <- igraph::add_edges(g2, data[[i+1]][-1])
# Call the engine to compute difference between g1 and g2
gc[[(i+1)/2]] <- GC_engine(g1=g1,g2=g2,gSumm=gSumm,distf=distf)
}
source("dist_engine.R")
gc <- vector("list",length(g/2))
for (i in seq(1,g,2)) {
# g1 and g2 must have the same number of nodes!
if (data[[i]][1] != data[[i+1]][1]) {
stop(paste("g1 and g2 must have the same # of nodes.
Error in sheets",i,"and",i+1))
}
# Create g1 and g2 as igraphs
g1 <- igraph::make_empty_graph(n = data[[i]][1], directed = FALSE)
g1 <- igraph::add_edges(g1, data[[i]][-1])
g2 <- igraph::make_empty_graph(n = data[[i+1]][1], directed = FALSE)
g2 <- igraph::add_edges(g2, data[[i+1]][-1])
# Call the engine to compute difference between g1 and g2
gc[[(i+1)/2]] <- GC_engine(g1=g1,g2=g2,gSumm=gSumm,distf=distf)
}
source("dist_engine.R")
setwd("C:/Users/amyti/Documents/Amy - COLLEGE/THESIS/thesis-gc/")
source("GC_engine.R")
source("dist_engine.R")
library(xlsx)
library(igraph)
library(clusteval)
################################## Read in data.
g <- length(xlsx::getSheets(loadWorkbook("data.xlsx")))
if (g %% 2 != 0) {
stop("The number of sheets must be even. For any graph pair,
each graph's sheet must be next to the other's.")
}
data <- vector("list",length(g))
for (i in 1:g) {
# First number = number of nodes in graph
data[[i]] <- as.vector(t( xlsx::read.xlsx("data.xlsx", sheetIndex = i, header = FALSE) ))[-1]
}
################################## Compute differences for all given graph pairs
# Setting parameters
gSumm <- c("cen_deg","cen_clo","cen_bet","ast",
"com_rw","com_im","com_bet","dis","eco","edh")
distf <- "l2"
gc <- vector("list",length(g/2))
for (i in seq(1,g,2)) {
# g1 and g2 must have the same number of nodes!
if (data[[i]][1] != data[[i+1]][1]) {
stop(paste("g1 and g2 must have the same # of nodes.
Error in sheets",i,"and",i+1))
}
# Create g1 and g2 as igraphs
g1 <- igraph::make_empty_graph(n = data[[i]][1], directed = FALSE)
g1 <- igraph::add_edges(g1, data[[i]][-1])
g2 <- igraph::make_empty_graph(n = data[[i+1]][1], directed = FALSE)
g2 <- igraph::add_edges(g2, data[[i+1]][-1])
# Call the engine to compute difference between g1 and g2
gc[[(i+1)/2]] <- GC_engine(g1=g1,g2=g2,gSumm=gSumm,distf=distf)
}
gc
g1
g2
igraph::assortativity_degree(g1)
help("assortativity.degree")
assortativity_degree(sample_gnp(10000, 3/10000))
igraph::assortativity_degree(g2)
igraph::assortativity_degree(g1)
igraph::assortativity_degree(g1) == na
na
source('~/Amy - COLLEGE/THESIS/thesis-gc/main.R', echo=TRUE)
setwd("C:/Users/amyti/Documents/Amy - COLLEGE/THESIS/thesis-gc/")
source("GC_engine.R")
source("dist_engine.R")
library(xlsx)
library(igraph)
library(clusteval)
################################## Read in data.
g <- length(xlsx::getSheets(loadWorkbook("data.xlsx")))
if (g %% 2 != 0) {
stop("The number of sheets must be even. For any graph pair,
each graph's sheet must be next to the other's.")
}
data <- vector("list",length(g))
for (i in 1:g) {
# First number = number of nodes in graph
data[[i]] <- as.vector(t( xlsx::read.xlsx("data.xlsx", sheetIndex = i, header = FALSE) ))[-1]
}
################################## Compute differences for all given graph pairs
# Setting parameters
gSumm <- c("cen_deg","cen_clo","cen_bet","ast",
"com_rw","com_im","com_bet","dis","eco","edh")
distf <- "l2"
gc <- vector("list",length(g/2))
for (i in seq(1,g,2)) {
# g1 and g2 must have the same number of nodes!
if (data[[i]][1] != data[[i+1]][1]) {
stop(paste("g1 and g2 must have the same # of nodes.
Error in sheets",i,"and",i+1))
}
# Create g1 and g2 as igraphs
g1 <- igraph::make_empty_graph(n = data[[i]][1], directed = FALSE)
g1 <- igraph::add_edges(g1, data[[i]][-1])
g2 <- igraph::make_empty_graph(n = data[[i+1]][1], directed = FALSE)
g2 <- igraph::add_edges(g2, data[[i+1]][-1])
# Call the engine to compute difference between g1 and g2
gc[[(i+1)/2]] <- GC_engine(g1=g1,g2=g2,gSumm=gSumm,distf=distf)
}
gc
g1
g2
GC_engine(g1=g2,g2=g2,gSumm=gSumm,distf=distf)
GC_engine(g1=g1,g2=g1,gSumm=gSumm,distf=distf)
help(combn)
gc
test1 <- c(1,2,3,4,5)
test2 <- c(1,2,3,5,4)
test1 < test2
length(test1 < test2)
count.TRUE(test1 < test2)
sum(test1 < test2)
gc
gc[[2]] <- gc[[1]]
gc
gc[[2]][1]
gc[[2]][1] <- 0
apply(combn(seq_along(gc),2), 2, function(n) sum(x[[n[1]]] < x[[n[2]]]))
apply(combn(seq_along(gc),2), 2, function(n) sum(gc[[n[1]]] < gc[[n[2]]]))
apply(combn(seq_along(gc),2), 2, function(n) sum(gc[[n[1]]] > gc[[n[2]]]))
apply(combn(seq_along(gc),2), 2, function(n) max(sum(gc[[n[1]]] < gc[[n[2]]]), sum(gc[[n[1]]] > gc[[n[2]]])))
gc[[3]] <- gc[[2]]
gc[[3]][2] <- 0
gc
gc[[3]][1] <- 1
gc
apply(combn(seq_along(gc),2), 2, function(n) max(sum(gc[[n[1]]] < gc[[n[2]]]), sum(gc[[n[1]]] > gc[[n[2]]])))
combn(seq_along(gc),2)
combn(seq_along(gc),2)
help(combn)
help(apply)
apply(combn(seq_along(gc),2), 2, function(n) print(n) )
apply(combn(seq_along(gc),2), 2, function(n) print(n) )
apply(combn(seq_along(gc),2), 2, function(n) max(sum(gc[[n[1]]] < gc[[n[2]]]), sum(gc[[n[1]]] > gc[[n[2]]])))
max(ll)
ll <- apply(combn(seq_along(gc),2), 2, function(n) max(sum(gc[[n[1]]] < gc[[n[2]]]), sum(gc[[n[1]]] > gc[[n[2]]])))
ll <- apply(combn(seq_along(gc),2), 2, function(n) max(sum(gc[[n[1]]] < gc[[n[2]]]), sum(gc[[n[1]]] > gc[[n[2]]])))
where(ll==max(ll))
ll <- apply(combn(seq_along(gc),2), 2, function(n) max(sum(gc[[n[1]]] < gc[[n[2]]]), sum(gc[[n[1]]] > gc[[n[2]]])))
which(ll==max(ll))
ll <- apply(combn(seq_along(gc),2), 2, function(n) max(sum(gc[[n[1]]] < gc[[n[2]]]), sum(gc[[n[1]]] > gc[[n[2]]])))
index <- which(ll==max(ll))
if (length(index) > 1) sample(index,1)
if (length(index) > 1) sample(index,1)
if (length(index) > 1) sample(index,1)
combn(seq_along(gc),2)
combn(seq_along(gc),2)[,1]
combn(seq_along(gc),2)[,3]
length(gc)
# Find first canditate "best"
best_c <- function(base,gc){
for (i in 1:length(gc)){
if (i != base){
if (sum(gc[[base]] < gc[[i]]) < sum(gc[[base]] > gc[[i]])){
return( i )
} else if (sum(gc[[base]] < gc[[i]]) > sum(gc[[base]] > gc[[i]])){
# do nothing
} else{
return( sample(c(base,i),1) )
}
}
}
return( base )
}
base <- 1 # start w/ index 1 and compare to everything else
old_idx <- 1
idx <- 0
j <- 0
while (j != length(gc) | old_idx == idx){
if (j!= 0) old_idx <- idx
idx <- best_c(base,gc)
j <- j+1
}
idx
gc
gc[[1]] <- c(10,9,8,7,6)
gc[[2]] <- c(10,8,7,9,6)
gc[[3]] <- c(10,8,6,9,6)
gc
base <- 1 # start w/ index 1 and compare to everything else
old_idx <- 1
idx <- 0
j <- 0
while (j != length(gc) | old_idx == idx){
if (j!= 0) old_idx <- idx
idx <- best_c(base,gc)
j <- j+1
}
# Find first canditate "best"
best_c <- function(base,gc){
for (i in 1:length(gc)){
if (i != base){
if (sum(gc[[base]] < gc[[i]]) < sum(gc[[base]] > gc[[i]])){
return( i )
} else if (sum(gc[[base]] < gc[[i]]) > sum(gc[[base]] > gc[[i]])){
# do nothing since the base is better
} else{
return( sample(c(base,i),1) )
}
}
}
return( base )
}
base <- 1 # start w/ index 1 and compare to everything else
old_idx <- 1
idx <- 0
j <- 0
while (j != length(gc) | old_idx != idx){
if (j!= 0) old_idx <- idx
idx <- best_c(base,gc)
j <- j+1
}
idx
gc[[2]]
gc[[3]]
base <- 1 # start w/ index 1 and compare to everything else
old_idx <- 1
idx <- 0
j <- 0
while (j != length(gc) | old_idx != idx){
if (j!= 0) old_idx <- idx
idx <- best_c(base,gc)
j <- j+1
print(j)
print(idx)
}
base <- 1 # start w/ index 1 and compare to everything else
old_idx <- 1
idx <- 0
j <- 0
while (j != length(gc) | old_idx != idx){
if (j!= 0) old_idx <- idx
idx <- best_c(base,gc)
j <- j+1
print(paste(j,old_idx,idx))
}
old_idx <- 2
idx <- 2
idx
j
j <- 2
j != length(gc)
old_idx != idx
(j != length(gc) | old_idx != idx)
old_idx
idx
old_idx==idx
old_idx !=idx
base <- 1 # start w/ index 1 and compare to everything else
old_idx <- 1
idx <- 0
j <- 0
while (old_idx != idx){
if (j!= 0) old_idx <- idx
idx <- best_c(base,gc)
j <- j+1
print(paste(j,old_idx,idx))
}
base
idx <- 1 # start w/ index 1 and compare to everything else
old_idx <- 1
j <- 0
while (old_idx != idx){
if (j!= 0) old_idx <- idx
idx <- best_c(idx,gc)
j <- j+1
print(paste(j,old_idx,idx))
}
old_idx
idx
idx <- 1 # start w/ index 1 and compare to everything else
old_idx <- 0
j <- 0
while (old_idx != idx){
if (j!= 0) old_idx <- idx
idx <- best_c(idx,gc)
j <- j+1
print(paste(j,old_idx,idx))
}
# Find first canditate "best"
best_c <- function(base,gc){
for (i in 1:length(gc)){
if (i != base){
if (sum(gc[[base]] < gc[[i]]) < sum(gc[[base]] > gc[[i]])){
return( i )
} else if (sum(gc[[base]] < gc[[i]]) > sum(gc[[base]] > gc[[i]])){
# do nothing since the base is better
} else{
return( sample(c(base,i),1) )
}
}
}
return( base )
}
idx <- 1 # start w/ index 1 and compare to everything else
old_idx <- 0
j <- 0
while (old_idx != idx){
if (j!= 0) old_idx <- idx
idx <- best_c(idx,gc)
j <- j+1
print(paste(j,old_idx,idx))
}
idx <- 1 # start w/ index 1 and compare to everything else
old_idx <- 0
while (old_idx != idx){
old_idx <- idx
idx <- best_c(idx,gc)
}
idx <- 1 # start w/ index 1 and compare to everything else
old_idx <- 0
while (old_idx != idx){
old_idx <- idx
idx <- best_c(idx,gc)
print(old_idx,idx)
}
idx <- 1 # start w/ index 1 and compare to everything else
old_idx <- 0
while (old_idx != idx){
old_idx <- idx
idx <- best_c(idx,gc)
print(paste(old_idx,idx))
}
gc
gc2[[1]] <- gc[[3]]
gc2 <- vector("list",3)
gc2[[1]] <- gc[[3]]
gc2[[2]] <- gc[[2]]
gc2[[3]] <- gc[[1]]
idx <- 1 # start w/ index 1 and compare to everything else
old_idx <- 0
while (old_idx != idx){
old_idx <- idx
idx <- best_c(idx,gc)
print(paste(old_idx,idx))
}
idx <- 1 # start w/ index 1 and compare to everything else
old_idx <- 0
while (old_idx != idx){
old_idx <- idx
idx <- best_c(idx,gc2)
print(paste(old_idx,idx))
}
gc2
# Search for the "most similar" graph pair
# (characterized by having the lowest differences across the board)
#
# gc is a list of the differences among various graph pairs
# base is the index with which to start the search
GC_selection <- function(gc, base = 1){
stopifnot(!is.null(gc))
idx <- base
old_idx <- 0
while (old_idx != idx){
old_idx <- idx
idx <- best_c(gc,idx)
#print(paste(old_idx,idx))
}
}
# Select the next idx candidate given current best candidate
best_c <- function(gc, cand){
for (i in 1:length(gc)){
if (i != cand){
if (sum(gc[[cand]] < gc[[i]]) < sum(gc[[cand]] > gc[[i]])){
return( i )
} else if (sum(gc[[cand]] < gc[[i]]) > sum(gc[[cand]] > gc[[i]])){
# do nothing since the current candidate is better
} else{
return( sample(c(cand,i),1) )
}
}
}
return( cand )
}
GC_selection(gc = gc, base = 1)
# Search for the "most similar" graph pair
# (characterized by having the lowest differences across the board)
#
# gc is a list of the differences among various graph pairs
# base is the index with which to start the search
GC_selection <- function(gc, base = 1){
stopifnot(!is.null(gc))
idx <- base
old_idx <- 0
while (old_idx != idx){
old_idx <- idx
idx <- best_c(gc,idx)
#print(paste(old_idx,idx))
}
}
# Select the next idx candidate given current best candidate
best_c <- function(gc, cand){
for (i in 1:length(gc)){
if (i != cand){
if (sum(gc[[cand]] < gc[[i]]) < sum(gc[[cand]] > gc[[i]])){
return( i )
} else if (sum(gc[[cand]] < gc[[i]]) > sum(gc[[cand]] > gc[[i]])){
# do nothing since the current candidate is better
} else{
return( sample(c(cand,i),1) )
}
}
}
return( cand )
}
print(GC_selection(gc = gc, base = 1))
# Search for the "most similar" graph pair
# (characterized by having the lowest differences across the board)
#
# gc is a list of the differences among various graph pairs
# base is the index with which to start the search
GC_selection <- function(gc, base = 1){
stopifnot(!is.null(gc))
idx <- base
old_idx <- 0
while (old_idx != idx){
old_idx <- idx
idx <- best_c(gc,idx)
#print(paste(old_idx,idx))
}
idx
}
# Select the next idx candidate given current best candidate
best_c <- function(gc, cand){
for (i in 1:length(gc)){
if (i != cand){
if (sum(gc[[cand]] < gc[[i]]) < sum(gc[[cand]] > gc[[i]])){
return( i )
} else if (sum(gc[[cand]] < gc[[i]]) > sum(gc[[cand]] > gc[[i]])){
# do nothing since the current candidate is better
} else{
return( sample(c(cand,i),1) )
}
}
}
return( cand )
}
print(GC_selection(gc = gc, base = 1))
idx <- GC_selection(gc = gc, base = 1)
idz
idx
idx <- GC_selection(gc = gc2, base = 1)
idx
